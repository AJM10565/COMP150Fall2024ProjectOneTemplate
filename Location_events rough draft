import json
import sys
import random
from typing import List, Optional
from enum import Enum


class EventStatus(Enum):
    UNKNOWN = "unknown"
    PASS = "pass"
    FAIL = "fail"
    PARTIAL_PASS = "partial_pass"


class Statistic:
    def __init__(self, name: str, value: int = 0, description: str = "", min_value: int = 0, max_value: int = 100):
        self.name = name
        self.value = value
        self.description = description
        self.min_value = min_value
        self.max_value = max_value

    def __str__(self):
        return f"{self.name}: {self.value}"

    def modify(self, amount: int):
        self.value = max(self.min_value, min(self.max_value, self.value + amount))


class Inventory:
    def __init__(self):
        self.items = {}

    def add_item(self, item: str, quantity: int = 1):
        if item in self.items:
            self.items[item] += quantity
        else:
            self.items[item] = quantity

    def use_item(self, item: str):
        if item in self.items and self.items[item] > 0:
            self.items[item] -= 1
            return True
        return False


class Character:
    def __init__(self, name: str, character_class: str):
        self.name = name
        self.character_class = character_class
        self.strength = 0
        self.inventory = Inventory()

    def collect_krabby_patties(self, count: int):
        self.strength += count
        self.inventory.add_item('Krabby Patty', count)

    def __str__(self):
        return f"{self.character_class}: {self.name}, Strength: {self.strength}, Inventory: {self.inventory.items}"


class Cook(Character):
    def __init__(self, name: str):
        super().__init__(name, "Cook")


class Cashier(Character):
    def __init__(self, name: str):
        super().__init__(name, "Cashier")


class Manager(Character):
    def __init__(self, name: str):
        super().__init__(name, "Manager")


class Customer(Character):
    def __init__(self, name: str):
        super().__init__(name, "Customer")


class Weapon:
    def __init__(self, name: str, damage: int):
        self.name = name
        self.damage = damage


class Event:
    def __init__(self, data: dict):
        self.primary_attribute = data['primary_attribute']
        self.secondary_attribute = data['secondary_attribute']
        self.prompt_text = data['prompt_text']
        self.pass_message = data['pass']['message']
        self.fail_message = data['fail']['message']
        self.partial_pass_message = data['partial_pass']['message']
        self.status = EventStatus.UNKNOWN

    def execute(self, party: List[Character], parser):
        print(self.prompt_text)
        character = parser.select_party_member(party)
        chosen_stat = parser.select_stat(character)
        self.resolve_choice(character, chosen_stat)

    def resolve_choice(self, character: Character, chosen_stat: Statistic):
        if chosen_stat.name == self.primary_attribute:
            self.status = EventStatus.PASS
            print(self.pass_message)
        elif chosen_stat.name == self.secondary_attribute:
            self.status = EventStatus.PARTIAL_PASS
            print(self.partial_pass_message)
        else:
            self.status = EventStatus.FAIL
            print(self.fail_message)


class Location:
    def __init__(self, events: List[Event]):
        self.events = events

    def get_event(self) -> Event:
        return random.choice(self.events)


class Combat:
    def __init__(self, player: Character, enemy: Character):
        self.player = player
        self.enemy = enemy

    def start_battle(self):
        while self.player.strength > 0 and self.enemy.strength > 0:
            # For simplicity, let's assume both deal random damage
            player_damage = random.randint(1, 5)
            enemy_damage = random.randint(1, 5)
            self.enemy.strength -= player_damage
            self.player.strength -= enemy_damage

            print(f"{self.player.name} attacks {self.enemy.name} for {player_damage} damage!")
            print(f"{self.enemy.name} attacks {self.player.name} for {enemy_damage} damage!")
            print(f"{self.player.name}'s strength: {self.player.strength}, {self.enemy.name}'s strength: {self.enemy.strength}")

        if self.player.strength > 0:
            print(f"{self.player.name} has defeated {self.enemy.name}!")
            reward_krabby_patties(self.player, 5)  # Reward after defeating the enemy
        else:
            print(f"{self.player.name} has been defeated!")


def reward_krabby_patties(character: Character, count: int):
    character.collect_krabby_patties(count)
    print(f"{character.name} gained {count} Krabby Patties!")


class UserInputParser:
    def parse(self, prompt: str) -> str:
        return input(prompt)

    def select_party_member(self, party: List[Character]) -> Character:
        print("Choose a party member:")
        for idx, member in enumerate(party):
            print(f"{idx + 1}. {member.name}")
        choice = int(self.parse("Enter the number of the chosen party member: ")) - 1
        return party[choice]

    def select_stat(self, character: Character) -> Statistic:
        print(f"Choose a stat for {character.name}:")
        stats = character.get_stats()
        for idx, stat in enumerate(stats):
            print(f"{idx + 1}. {stat.name} ({stat.value})")
        choice = int(self.parse("Enter the number of the stat to use: ")) - 1
        return stats[choice]


def load_events_from_json(file_path: str) -> List[Event]:
    with open(file_path, 'r') as file:
        data = json.load(file)
    return [Event(event_data) for event_data in data]


def start_game():
    parser = UserInputParser()
    characters = [Cook("SpongeBob"), Cashier("Squidward"), Manager("Mr. Krabs")]

    # Load events from the JSON file
    events = load_events_from_json('project_code/location_events/location_1.json')

    locations = [Location(events)]
    game = Game(parser, characters, locations)
    game.start()


class Game:
    def __init__(self, parser, characters: List[Character], locations: List[Location]):
        self.parser = parser
        self.party = characters
        self.locations = locations
        self.continue_playing = True

    def start(self):
        while self.continue_playing:
            location = random.choice(self.locations)
            event = location.get_event()
            event.execute(self.party, self.parser)

            if self.check_game_over():
                self.continue_playing = False

        print("Game Over.")

    def check_game_over(self):
        return len(self.party) == 0


if __name__ == '__main__':
    start_game()
